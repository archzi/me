# 面试题浅析 打印目录树
在面试的过程中经常会碰到这样一道题

有以下节点，编写一段程序，输出以下节点的树形结构（类似于文件目录结构）。
name|id|pid
---|---|---
AA|1|0
BB|2|1
CC|3|1
DD|4|1
EE|5|2
FF|6|5
GG|7|4
HH|8|5
II|9|4
UU|10|0
ZZ|11|10

相信大家对于这样的题目就肯定不陌生，毕竟在项目中经常需要多级菜单等等，但是如果写出比较好的答案却没有统一的答案。这里就简单分析两种解法，分别是递归法和树的深度优先遍历

## 递归解法
首先对于这种题目大家肯定会用最简单的`递归算法`,那么这里的递归基线为：`节点是否有子节点`，如果有子节点那么继续递归。

其代码大概如下：
```java
public static void printRecursive(Node n, int level, List<Node> list) {
        for (int i = 0; i < level - 1; i++) {
            System.out.print("   ");
        }
        if (n.pId != 0) {
            System.out.print("|");
        }
        for (int j = Math.max(level - 1, 0); j < level; j++) {
            System.out.print("--");
        }
        System.out.println(n.name);
        List<Node> children = findChildren(n.id, list);
        if (!children.isEmpty()) {
            for (Node i : children) {
                printRecursive(i, level + 1, list);
            }
        }
    }
```
> 注：代码中打印缩紧的代码不影响主流程

## 树的深度优先遍历
如果对数据结构熟悉并且对操作系统有一定了解的朋友肯定知道程序的递归算法本质为`方法调用栈`不断出栈入栈来完成，而如果节点数很多的时候就会发生达到系统最大递归深度，简单来说就是爆栈了。这是因为我们的栈深度太深导致。如何避免此问题，最简单的方法就是增加栈深度，而虚拟机方法栈深度涉及面比较广，最好的方式就是我们自己创建一个栈空间来用，而 ArrayDeque 对象背后是动态数组，其深度肯定能满足我们的需求，那么对应的代码如下：
```java
public static void printIndentNodeWithStack(List<Node> nodes) {
        for (Node node : nodes) {
            Deque<Node> nodeStack = new ArrayDeque<>();
            Deque<Integer> countStack = new ArrayDeque<>();
            if (node.pId == 0) {
                nodeStack.add(node);
                int count = 0;
                countStack.push(count);
                while (!nodeStack.isEmpty()) {
                    Node topNode = nodeStack.pop();
                    int j = countStack.pop();
                    if (j != 0) {
                        for (int jj = 0; jj < (j - 1); jj++) {
                            System.out.print("   ");
                        }
                        System.out.print(" |-");
                    }
                    System.out.println(topNode.name);
                    List<Node> children = findChildren(topNode.id, nodes);
                    if (children.isEmpty()) {
                        count--;
                        continue;
                    }
                    count++;
                    for (int i1 = children.size() - 1; i1 >= 0; i1--) {
                        nodeStack.push(children.get(i1));
                        countStack.push(count);
                    }
                }
            }
        }
    }
```
> 以上代码中用了两个栈空间来保存需要遍历的对象和每个对象的缩进值。

## JAVA 源码 FileTreeWalker 解析

其实这道面试题能答道上述两种算法，一般来说面试官就比较满意了，但是肯定有朋友和笔者一样不满足于此，因为上述 深度优先遍历也只是在原先递归算法的基础上增加了栈深度来防止爆栈，但是还是比较浪费空间的，其空间复杂度肯定不能满足工业级应用，那么真正的工业级应用的代码是什么样子呢？带着这个疑问，我点开了 JAVA FileTreeWalker 类的源码，接下来我们一起来分析

### 



### 




